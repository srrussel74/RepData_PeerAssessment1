---
title: "Reproducible Research: Peer Assessment 1"
output: 
  html_document:
    keep_md: true
---
```{r global_options}
library(knitr)
opts_chunk$set( fig.path='figure/', echo=TRUE, warning=TRUE, message=TRUE)
```

## Loading and preprocessing the data
After unzip activity.zip to activity.csv in same working directory, the git repository. Data from activity.csv is generated by personal activity monitor device.
Loading activity.csv by:
```{r,}
data<-read.csv("activity.csv")
```
The checking dimensions of _data_ shows that there are three variables: _steps_, _date_ and _interval_. Total observations from each interval of five minutes during two months is 17,568 (= 30+31 days\*24 hours\*(60 minutes/5 minutes). It is confirmed by:
```{r}
dim(data)
```
_data_ is preprocessing as following:
There are missing observations. _dataWN_ is created from _data_ __w__ithout _N_A:

```{r}
dataWN<-na.omit(data)
```
The column steps from _dataWN_ is stored in dataset _steps_. So same way for column _interval_ from _dataWN_.
```{r, echo=TRUE}
steps<-dataWN$steps
interval<-dataWN$interval
```
dataset _steps_ are total amount of steps taken in a 5 minutes interval as integer. A value from _interval_ is noted as 'HM', where H is number of hours from 00:00 and M is multiple of 5 minutes. For example the interval labeled with '2355' means 5 minutes interval from 23:55h. In other words, it is the interval between 23:55 and 00:00. So notice there is the total 288 intervals per day. 
The class of column _date_ is converting into class Date before storing into new dataset _date_:
```{r}
dataWN$date<-as.Date(as.character(dataWN$date),format="%Y-%m-%d");
date<-dataWN$date
```

## What is mean total number of steps taken per day?

We take column _steps_ and group rows by days. For each group, the number of steps are to add up by function _sum()_. So total number of steps per day is calculated by:
```{r}
tsd<-aggregate(steps,list(date),sum)
```
The dataset _tsd_ contains values of __t__otal number of __s__teps per __d__ay. 
The dataset _sumstep_ is the column of total number of steps from _tsd_:
```{r}
sumsteps<-tsd[,2]
```
The result is viewed at the next histogram:
```{r name="hist"}
hist(
     sumsteps, 
     xlab="Total number of steps taken per day",
     main="",
     breaks=10,
     col=rgb(1,0,0,0.7)
     )
```

The mean total number of steps taken per day is:
```{r}
mean(sumsteps)
```
And the median total number of steps taken per day is:
```{r}
median(sumsteps)
```

## What is the average daily activity pattern?

The plot of 5 minute interval as variable for x-axis and the average number of steps taken averaged across all days as variable for y-axis has got dataset _asi_, obtained by the following calculation:

```{r}
asi<-aggregate(steps~interval,list(interval),mean)
```
The dataset _asi_ is the __a__verage of numbers of __s__teps per __i__nterval and has got two sorts of values, interval and the average of numbers of steps.
The graph with _asi_ is shown:
```{r}
plot(asi, type='l', ylab="average number of steps", xlab="interval")
```

To find an interval which the number of steps is maximum, firstly we create dataset _msi_ almost same way as last time, but then with function _max()_ instead of _mean()_:
```{r}
msi<-aggregate(steps~interval,list(interval),max)
```
The variable _msi_ is the dataset included __m__aximum number of __s__teps taken  per __i__nterval. Now the interval with maximum of all maximum numbers of steps per interval, which are included in _msi\$steps_, can be found by:
```{r}
interval_max_steps<- msi$interval[which.max(msi$steps)]
```
The answer is: interval `r interval_max_steps`. So the maximum number of steps is taken at 06:15 in morning.

## Imputing missing values

The amount of rows with _NA_'s on _data_ is:
```{r}
sum(is.na(data))
```

So the percentage of missing values from _data_ is 
```{r}
percentage<-mean(is.na(data))*100
```
It is `r percentage `%.

The strategy to replace _NA_'s with new values is explain as following:
Get dataset _NAdata_ as subset with rows contained _NA_ from _data_:
```{r}
NAdata<-data[which(is.na(data)),]
```
To study how _NA_'s is spreading, _NAdata_ is considered. There are 8 days where values are missing:
```{r}
unique(NAdata$date)
```
It is given that total amount of missing values, `r sum(is.na(data))`, divided by `r length(unique(NAdata$date))` (days) results to 288, which is equal to total number of interval per day. So the expectation is that only these whole days are missing values.
To confirm this for each of this 8 days, it is checking for _i=1_`r i<-1`, which means "`r NAdata$date[i]`":

```{r}
sum(data$date==NAdata$date[i])
```
Repeat the confirmation for each day from _NAdata\$date_ (_i_=2,..,8) shows same result given as 288 or day. So in fact new values have to be inserting into all 288 intervals of given day.

The explaination of strategy continues about creating new values.
Consider each day, noted as _i_, the _m_ean number of steps as _m[i]_:
```{r}
m<-aggregate(data$step,list(data$date),mean)[,2]
```
Note there are _NA_'s in set _m_.
If a row of first day from _m_ has got a missing value, then the new value for _m[1]_ is:
```{r}
m[1]<-m[2]
```

The underlying idea for this inserted value is that the missing value is replaced by average value of steps taken from next day.

For the rest of days, the dataset _m_ is fullfilled, according to:

When a value is missing for a day _i_, then the new value will be an average of mean values from neighbouring, later and earlier, days. If there is a missing value in a day later then calculation of mean will not be done and the value from earlier day will be inserting. It all is coded as:
```{r}
for(i in 2:length(m))
  {
  if(is.na(m[i]))
    {
    if(is.na(m[i+1]))
      {
      m[i]<-m[i-1]
    }else
      {
        m[i]<-0.5*(m[i+1]+m[i-1])
    }
  }
}
```

The _NA_'s in _data_ are replaced by _m[i]_, with _i_, correspondening _date_. A set _M_ is formed as set of days where the vaules are missing:
```{r}
M<-unique(NAdata$date)
```
Create new dataset _Ndata_ where _NA_'s are replaced by new values from set _m_ as following:
```{r}
Ndata<-data
for( day in M ){
  Ndata$steps[which(Ndata$date==day)]<-
    m[which(unique(Ndata$date)==as.character(day))]
}
```
The procedure after creating Ndata (after first line of last block code ) is: it is given that the length of _m_ is equal to 61 days. So does _Ndata\$date_. So for each day as a set rows where _NA_ is found, from _Ndata_, the column _steps_  is filled by the value from _m_ corresponding to same day. Remind that _M_ contains days where values are missing. So procedure is focused on these days.

The new dataset _Ndata_ is comparing with _dataWN_:  
```{r}
Ntpd<-aggregate(Ndata$steps,list(Ndata$date),sum)
```
```{r}
Nsum_steps<-Ntpd[,2]
```
The dataset _Ntpd_ have got __n__ew values instead of _NA_'s in set __t__otal number of steps __p__er __d__ay . 
The result is presented as the next histogram overlapped with earlier histogram (the one without new values):
```{r}
hist( #blue
     Nsum_steps,
     xlim=c(0,max(Nsum_steps)),
     ylim=c(0,20),
     col=rgb(0,0,1,1),
     xlab="Total number of steps taken per day",
     main="",
     breaks=10
     )

hist( # red
     sumsteps,
     xlim=c(0,25000),
     ylim=c(0,20),
     col=rgb(1,0,0,0.7),
     xlab="Total number of steps taken per day",
     main="",
     breaks=10,
     add=TRUE
     )
```

Here we see two histograms overlapped: transparant and red colored histogram is from _data\$steps_ and blue colored histogram is from _Ndata\$steps_, so with new values. Notice how the information of 8 days with new values are adding as blue parts. 
Continue the comparing:
Average of total number of steps taken per day is:
```{r}
mean(Nsum_steps)
```
And median of total number of stepstaken per day is:
```{r}
median(Nsum_steps)
```
These values differs from mean and median of numbers from _dataWN_ where _NA_'s are omitting. And new dataset has got more values, so average value decreases. Despite that the sum of the number of steps taken increases. That is because of the fact that the increasing sum does relatively not have an effect above the effect from the changing length of dataset. This combined by fact that the strategy for new values are based on averages. Check earlier chunk code for creating dataset _m_.
About median, there also are more values in _Ndata_ then in _dataWN_. Considering the histogram, the lower numbers are adding relatively more than higher numbers. So median value is more 'influenced' by lower values, resulting in lower value then value based on _dataWN_.
Conclusion is that the adding new values based on the above described strategy brings more effect from lower values on estimates of total daily number of steps.

## Are there differences in activity patterns between weekdays and weekends?

Using dataset _Ndata_, a new dataset _W_, contained factor variables with levels "weekday" and "weekend", is formed by: 
```{r}
W<-weekdays(as.Date(Ndata$date))

W[which((W=="Saturday")|(W=="Sunday"))]<-"weekend"
W[which((W!="weekend"))]<-"weekday"

W<-factor(W, level=c("weekend","weekday"))
```
The level indicates a date, as being a day from week or weekend.
```{r}
Wsi<-aggregate(Ndata$steps,list(interval=Ndata$interval, W=W),mean)
colnames(Wsi)<-c("interval","W","steps")
```
The dataset _Wsi_ is average number of __s__teps per __i__nterval divided into two groups by two kinds of days: weekday and weekend (__W__).

The panel plot for each group from dataset _Wsi_ is given by:
```{r}
library(lattice)

xyplot(
  steps~interval|W,
  type="l",
  data=Wsi,
  xlab="interval",
  ylab="average number of steps taken",
  layout=c(1,2)
  )
```

There are some differences with patterns between weekday and weekend. There are more activites in morning of weekday then weekend and increase of step activites in weekday's moring around 6:00 is far more than in weekend's. The visual estimation from patterns shows the activites during a day are more in weekend then weekday. 
No scientific suppostion is that a sort working or school life does matter to difference between patterns of weekday and weekend.